exit
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(smacof)
library(cluster)
library(lubridate)
source("utilerias/funciones.R")
data <- read.csv("Indica.csv")
rownames(data) <- data$Entidad.Federativa # Estableciendo como indice las entidades
data$Entidad.Federativa <- NULL # Estableciendo como indice las entidades
# Establecimiendo de escalas ordinales
data$Grado.de.rezago.social <- factor(data$Grado.de.rezago.social, levels= c("Muy bajo", "Bajo","Medio","Alto","Muy alto"), order=TRUE)
auxiliares <- colnames(data[, c(2,15)])
analisis <- colnames(data[,3:12]) # Seleccion de columnas
columnas <- c(auxiliares, analisis)
datos <- data[, columnas] # Extraccion
# Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categóricas
nominales <- which( tipo == "factor") # categóricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews
andrews(df = datos, type=2, bty = "n", ylab="f(t)", xlab="t",lwd=1,
main="Grafico Andrews" ); grid()
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(smacof)
library(cluster)
library(lubridate)
source("utilerias/funciones.R")
data <- read.csv("Indica.csv")
rownames(data) <- data$Entidad.Federativa # Estableciendo como indice las entidades
data$Entidad.Federativa <- NULL # Estableciendo como indice las entidades
# Establecimiendo de escalas ordinales
data$Grado.de.rezago.social <- factor(data$Grado.de.rezago.social, levels= c("Muy bajo", "Bajo","Medio","Alto","Muy alto"), order=TRUE)
auxiliares <- colnames(data[, c(2,15)])
analisis <- colnames(data[,3:12]) # Seleccion de columnas
columnas <- c(auxiliares, analisis)
datos <- data[, columnas] # Extraccion
# Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categóricas
nominales <- which( tipo == "factor") # categóricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews ##CORREGIR!!!
#andrews(df = datos, type=2, bty = "n", ylab="f(t)", xlab="t",lwd=1,
main="Grafico Andrews" ); grid()
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(smacof)
library(cluster)
library(lubridate)
source("utilerias/funciones.R")
data <- read.csv("Indica.csv")
rownames(data) <- data$Entidad.Federativa # Estableciendo como indice las entidades
data$Entidad.Federativa <- NULL # Estableciendo como indice las entidades
# Establecimiendo de escalas ordinales
data$Grado.de.rezago.social <- factor(data$Grado.de.rezago.social, levels= c("Muy bajo", "Bajo","Medio","Alto","Muy alto"), order=TRUE)
auxiliares <- colnames(data[, c(2,15)])
analisis <- colnames(data[,3:12]) # Seleccion de columnas
columnas <- c(auxiliares, analisis)
datos <- data[, columnas] # Extraccion
# Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categóricas
nominales <- which( tipo == "factor") # categóricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews ##CORREGIR!!!
#andrews(df = datos, type=2, bty = "n", ylab="f(t)", xlab="t",lwd=1, main="Grafico Andrews" ); grid()
outliers <- boxplot(datos$Poblacion.Total)$out
elementos <- which(datos$Poblacion.Total %in% outliers)
datos <- datos[-union(elementos,elementos), ]
# Normalizacion
datos[,analisis] <- sapply(datos[, analisis], function(data){
(data - min(data)) / (max(data) - min(data))})
# Boxplot
boxplot(datos[, analisis], main="Caja y Bigotes", family="Ubuntu Condensed",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
datos[, analisis] <- round(datos[, analisis])
for(indice in analisis){
for(n in 1:nrow(datos)){
datos[n,indice] = recode(datos[n,indice], "0:20=1; 21:40=2; 41:60=3; 61:80=4; 81:100=5")
}
}
# Formato Correcto
for(indice in analisis){
datos[, indice] <- factor(datos[, indice], order = TRUE)
}
# Redefinicion de Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categoricas
nominales <- which( tipo == "factor") # categoricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
gower_dist <- daisy(datos[, analisis], metric = "gower")
fit.datos <- smacofSym(gower_dist, type = "ordinal", ndim = 7)
fit.datos$stress
fit.datos$rss
# Dispersion
plot(fit.datos, plot.dim = c(1,2), main = "Escalamiento Multidimensional No metrico",
xlab="Dim 1", ylab="Dim 2", cex=0.5, cex.main=1,
bty = "n",  col = datos$Grado.de.rezago.social );grid()
# Curva Shape
plot(fit.datos, plot.type = "Shepard", main="Curva Shepard",
xlab="Distancias observadas", ylab="Configuracion de distancias", cex=0.5, cex.main=1,
col="skyblue", bty = "n");grid()
reticulate::repl_python()
from sklearn.manifold import TSNE
import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# Datos
datos = r.datos
# Particion horizontal
x = np.array(datos[r.analisis])
y = np.array(datos[r.auxiliares[1]]) # Variable suplementaria
x_coord = TSNE(n_components = 3, perplexity = 30, n_iter = 4000).fit_transform(x)
plt.clf()
sns.set(style="whitegrid")
sns.relplot(x=x_coord[:,0], y=x_coord[:,1], hue=y, palette="muted" )
plt.show()
exit
knitr::opts_chunk$set(echo = TRUE)
library(car)
library(smacof)
library(cluster)
library(lubridate)
source("utilerias/funciones.R")
data <- read.csv("Indica.csv")
rownames(data) <- data$Entidad.Federativa # Estableciendo como indice las entidades
data$Entidad.Federativa <- NULL # Estableciendo como indice las entidades
# Establecimiendo de escalas ordinales
data$Grado.de.rezago.social <- factor(data$Grado.de.rezago.social, levels= c("Muy bajo", "Bajo","Medio","Alto","Muy alto"), order=TRUE)
auxiliares <- colnames(data[, c(2,15)])
analisis <- colnames(data[,3:12]) # Seleccion de columnas
columnas <- c(auxiliares, analisis)
datos <- data[, columnas] # Extraccion
# Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categóricas
nominales <- which( tipo == "factor") # categóricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews ##CORREGIR!!!
#andrews(df = datos, type=2, bty = "n", ylab="f(t)", xlab="t",lwd=1, main="Grafico Andrews" ); grid()
outliers <- boxplot(datos$Poblacion.Total)$out
elementos <- which(datos$Poblacion.Total %in% outliers)
datos <- datos[-union(elementos,elementos), ]
# Normalizacion
datos[,analisis] <- sapply(datos[, analisis], function(data){
(data - min(data)) / (max(data) - min(data))})
# Boxplot
boxplot(datos[, analisis], main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
datos[, analisis] <- round(datos[, analisis])
for(indice in analisis){
for(n in 1:nrow(datos)){
datos[n,indice] = recode(datos[n,indice], "0:20=1; 21:40=2; 41:60=3; 61:80=4; 81:100=5")
}
}
# Formato Correcto
for(indice in analisis){
datos[, indice] <- factor(datos[, indice], order = TRUE)
}
# Redefinicion de Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categoricas
nominales <- which( tipo == "factor") # categoricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
gower_dist <- daisy(datos[, analisis], metric = "gower")
fit.datos <- smacofSym(gower_dist, type = "ordinal", ndim = 7)
fit.datos$stress
fit.datos$rss
# Dispersion
plot(fit.datos, plot.dim = c(1,2), main = "Escalamiento Multidimensional No metrico",
xlab="Dim 1", ylab="Dim 2", cex=0.5, cex.main=1,
bty = "n",  col = datos$Grado.de.rezago.social );grid()
# Curva Shape
plot(fit.datos, plot.type = "Shepard", main="Curva Shepard",
xlab="Distancias observadas", ylab="Configuracion de distancias", cex=0.5, cex.main=1,
col="skyblue", bty = "n");grid()
reticulate::repl_python()
from sklearn.manifold import TSNE
import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# Datos
datos = r.datos
# Particion horizontal
x = np.array(datos[r.analisis])
y = np.array(datos[r.auxiliares[1]]) # Variable suplementaria
x_coord = TSNE(n_components = 3, perplexity = 30, n_iter = 4000).fit_transform(x)
plt.clf()
sns.set(style="whitegrid")
sns.relplot(x=x_coord[:,0], y=x_coord[:,1], hue=y, palette="muted" )
plt.show()
exit
knitr::opts_chunk$set(echo = TRUE)
library(psych)
source("utilerias/funciones.R")
library(andrews)
library(psych)
source("utilerias/funciones.R")
library(andrews)
data <- read.csv("Indica.csv")
rownames(data) <- data$Entidad.Federativa # Estableciendo como indice las entidades
data$Entidad.Federativa <- NULL # Estableciendo como indice las entidades
# Establecimiendo de escalas ordonales
data$Grado.de.rezago.social <- factor(data$Grado.de.rezago.social, levels= c("Muy bajo", "Bajo","Medio","Alto","Muy alto"), order=TRUE)
auxiliares <- colnames(data[, c(2,15)])
analisis <- colnames(data[,3:12]) # Seleccion de columnas
columnas <- c(auxiliares, analisis)
datos <- data[, columnas] # Extraccion
# Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categoricas
nominales <- which( tipo == "factor") # categoricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes", family="Ubuntu Condensed",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews
andrews(df = datos, type=2, family="Ubuntu Condensed", bty = "n",
ylab="f(t)", xlab="t",lwd=1, main="Grafico Andrews" );grid()
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews
andrews(df = datos, type=2, family="Ubuntu Condensed", bty = "n",
ylab="f(t)", xlab="t",lwd=1, main="Grafico Andrews" );grid()
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews
andrews(df = datos, type=2, bty = "n",
ylab="f(t)", xlab="t",lwd=1, main="Grafico Andrews" );grid()
outliers <- boxplot(datos$Poblacion.Total)$out
elementos <- which(datos$Poblacion.Total %in% outliers)
datos <- datos[-union(elementos,elementos), ]
# Normalizacion
datos[,analisis] <- sapply(datos[, analisis], function(data){
(data - min(data)) / (max(data) - min(data))})
# Boxplot
boxplot(datos[, analisis], main="Caja y Bigotes", family="Ubuntu Condensed",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Normalizacion
datos[,analisis] <- sapply(datos[, analisis], function(data){
(data - min(data)) / (max(data) - min(data))})
# Boxplot
boxplot(datos[, analisis], main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Normalizacion
datos[,analisis] <- sapply(datos[, analisis], function(data){
(data - min(data)) / (max(data) - min(data))})
# Boxplot
boxplot(datos[, analisis], main="Caja y Bigotes", family="Ubuntu Condensed",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Normalizacion
datos[,analisis] <- sapply(datos[, analisis], function(data){
(data - min(data)) / (max(data) - min(data))})
# Boxplot
boxplot(datos[, analisis], main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
datos[, analisis] <- round(datos[, analisis])
for(indice in analisis){
for(n in 1:nrow(datos)){
datos[n,indice] = recode(datos[n,indice], "0:20=1; 21:40=2; 41:60=3; 61:80=4; 81:100=5")
}
}
# Formato Correcto
for(indice in analisis){
datos[, indice] <- factor(datos[, indice], order = TRUE)
}
# Redefinicion de Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categoricas
nominales <- which( tipo == "factor") # categoricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
# Formato Correcto para R.
for(indice in analisis){
datos[, indice] <- as.integer(datos[, indice])
}
# Correlacion
R <- cor(datos[, analisis], method = "spearman")
# Prueba de Bartlet Ho: R = I
p_esf <- cortest.bartlett(R, 200)
p_esf$p < 0.05
# Prueba de KMO
pruebaKMO <- KMO(R)
parallel <- fa.parallel(R, fm="pa", fa='fa') # Paralelo, Componentes principales, sin rotacion
scree(datos[, analisis]);grid() # Scree
k <- 2 # Numero de factores
ajuste <- fa(R, nfactors = k, rotate = "none", fm="pa")
print(ajuste, digits=2, cutoff=0.3, sort=TRUE)
ajuste$loadings # Cargas estimadas
fa.diagram(ajuste)
ajuste_varimax <- fa(R, nfactors = k, rotate = "varimax", fm="pa")
print(ajuste, digits=2, cutoff=0.3, sort=TRUE)
ajuste_varimax$loadings # Cargas estimadas
fa.diagram(ajuste_varimax)
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
datos[, analisis] <- round(datos[, analisis])
for(indice in analisis){
for(n in 1:nrow(datos)){
datos[n,indice] = recode(datos[n,indice], "0:20=1; 21:40=2; 41:60=3; 61:80=4; 81:100=5")
}
}
# Formato Correcto
for(indice in analisis){
datos[, indice] <- factor(datos[, indice], order = TRUE)
}
# Redefinicion de Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categoricas
nominales <- which( tipo == "factor") # categoricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
library(psych)
source("utilerias/funciones.R")
library(andrews)
library(dplyr)
library(psych)
source("utilerias/funciones.R")
library(andrews)
library(dplyr)
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
datos[, analisis] <- round(datos[, analisis])
for(indice in analisis){
for(n in 1:nrow(datos)){
datos[n,indice] = recode(datos[n,indice], "0:20=1; 21:40=2; 41:60=3; 61:80=4; 81:100=5")
}
}
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
knitr::opts_chunk$set(echo = TRUE)
library(psych)
source("utilerias/funciones.R")
library(andrews)
library(dplyr)
data <- read.csv("Indica.csv")
rownames(data) <- data$Entidad.Federativa # Estableciendo como indice las entidades
data$Entidad.Federativa <- NULL # Estableciendo como indice las entidades
# Establecimiendo de escalas ordonales
data$Grado.de.rezago.social <- factor(data$Grado.de.rezago.social, levels= c("Muy bajo", "Bajo","Medio","Alto","Muy alto"), order=TRUE)
auxiliares <- colnames(data[, c(2,15)])
analisis <- colnames(data[,3:12]) # Seleccion de columnas
columnas <- c(auxiliares, analisis)
datos <- data[, columnas] # Extraccion
# Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categoricas
nominales <- which( tipo == "factor") # categoricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews
andrews(df = datos, type=2, bty = "n",
ylab="f(t)", xlab="t",lwd=1, main="Grafico Andrews" );grid()
outliers <- boxplot(datos$Poblacion.Total)$out
elementos <- which(datos$Poblacion.Total %in% outliers)
datos <- datos[-union(elementos,elementos), ]
# Normalizacion
datos[,analisis] <- sapply(datos[, analisis], function(data){
(data - min(data)) / (max(data) - min(data))})
# Boxplot
boxplot(datos[, analisis], main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
datos[, analisis] <- round(datos[, analisis])
for(indice in analisis){
for(n in 1:nrow(datos)){
datos[n,indice] = dplyr:::recode.character(datos[n,indice], "0:20=1; 21:40=2; 41:60=3; 61:80=4; 81:100=5")
}
}
knitr::opts_chunk$set(echo = TRUE)
library(psych)
source("utilerias/funciones.R")
library(andrews)
library(dplyr)
data <- read.csv("Indica.csv")
rownames(data) <- data$Entidad.Federativa # Estableciendo como indice las entidades
data$Entidad.Federativa <- NULL # Estableciendo como indice las entidades
# Establecimiendo de escalas ordonales
data$Grado.de.rezago.social <- factor(data$Grado.de.rezago.social, levels= c("Muy bajo", "Bajo","Medio","Alto","Muy alto"), order=TRUE)
auxiliares <- colnames(data[, c(2,15)])
analisis <- colnames(data[,3:12]) # Seleccion de columnas
columnas <- c(auxiliares, analisis)
datos <- data[, columnas] # Extraccion
# Escalas
tipo <- sapply(datos, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categoricas
nominales <- which( tipo == "factor") # categoricas
ordinales <- which( sapply(datos, is.ordered) )  # ordinales
fecha <- which(tipo == "Date") # Fecha
categoricas <- names(c(nominales, ordinales, fecha))
# Histogramas
multi.hist(datos[, numericas])
# Boxplot
boxplot(datos, main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Andrews
andrews(df = datos, type=2, bty = "n",
ylab="f(t)", xlab="t",lwd=1, main="Grafico Andrews" );grid()
outliers <- boxplot(datos$Poblacion.Total)$out
elementos <- which(datos$Poblacion.Total %in% outliers)
datos <- datos[-union(elementos,elementos), ]
# Normalizacion
datos[,analisis] <- sapply(datos[, analisis], function(data){
(data - min(data)) / (max(data) - min(data))})
# Boxplot
boxplot(datos[, analisis], main="Caja y Bigotes",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
# Transformacion a escala ordinal
datos[, analisis] <- datos[, analisis]*100
datos[, analisis] <- round(datos[, analisis])
for(indice in analisis){
for(n in 1:nrow(datos)){
datos[n,indice] = recode(datos[n,indice], "0:20=1; 21:40=2; 41:60=3; 61:80=4; 81:100=5")
}
}
