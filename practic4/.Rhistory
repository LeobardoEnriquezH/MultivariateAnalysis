# Configuracion global de los bloques de codigo (chunk's)
knitr::opts_chunk$set(
echo = FALSE,
fig.align = "center",
fig.dim = c(6, 5),
message = FALSE,
warning = FALSE,
error = F
)
#instalalmos las librerias a ocupar
library(dplyr)
library(cluster)
library(reticulate)
library(factoextra)
library(FactoMineR)
library(ggplot2)
library(andrews)
library(fpc)
library(scatterplot3d)
library(MASS)
library(Rtsne)
library(clusterCrit)
library(clustMixType)
library(DataExplorer)
library(readr)
library(GGally)
library(psych)
data <- read_csv("costumer-segmentation.csv")
summary(data)
# Escalas
tipo <- sapply(data, class)
continuas <-  which(tipo == "numeric") # continuas
enteras <- which(tipo == "integer") # enteras
numericas <- names(c(continuas,enteras))
# Variables Categoricas
nominales <- which( tipo == "factor") # categoricas
ordinales <- which( sapply(data, is.ordered) )  # ordinales
categoricas <- names(c(nominales, ordinales))
fecha <- which(tipo == "Date") # Fecha
#vamos a convertir a factor las variables de tipo caracter para manipularlas mejor
#datos_numericos <- subset(datos,select = c('ID','Age','Work_Experience','Family_Size'))#seleccionamos unicamente las vatriables numericas
# Veamos si existen datos faltantes
length(complete.cases(data))
# Histogramas
multi.hist(data[, numericas])
# Boxplot
boxplot(data[,numericas], main="Caja y Bigotes", family="Ubuntu Condensed",
frame = FALSE, xlab="Variables", ylab= "Escala Normal", cex=0.4);grid()
boxplot(data$Age, main = "Edades", family = "Ubuntu Condensed", frame = F, xlab = "Age", ylab = "Escala original", cex = 0.4, col = "steelblue");grid()
boxplot(data$Work_Experience, main = "BoxPlot Experiencia laboral", family = "Ubuntu Condensed",
frame = F, xlab = "", ylab = "Años", cex = 0.4, col = "steelblue");grid()
boxplot(data$Family_Size, main = "BoxPlot Tamaño Familia", family = "Ubuntu Condensed",
frame = F, xlab = "", ylab = "Integrantes", cex = 0.4, col = "steelblue");grid()
# Andrews
andrews(df = data, type=2, family="Ubuntu Condensed", bty = "n",
ylab="f(t)", xlab="t",lwd=1, main="Grafico Andrews" );grid()
ggpairs(data,mapping = aes(color = Segmentation))
auxiliares <- subset(data,select = c('ID','Age','Work_Experience','Family_Size'))
columnas <- setdiff(colnames(data), c(auxiliares,categoricas) )
datos_numericos <- subset(data,select = c('ID','Age','Work_Experience','Family_Size'))#seleccionamos los datos a normalizar
datos_normalizados <- sapply(datos_numericos, function(data){
(data - min(data)) / (max(data) - min(data))})
datos_std <- scale(datos_numericos)
rownames(datos_std) <- rownames(datos_numericos)
datos_std <- as.data.frame(datos_std)
auxiliares <- subset(data,select = c('ID','Age','Work_Experience','Family_Size'))
columnas <- setdiff(colnames(data), auxiliares)
# Generacion de clusters a diferentes particiones
Es <- numeric(10)
for(i in 1:10){
kpres <- kmeans(datos_std[,numericas], k = i, nstart = 5)
Es[i] <- kpres$tot.withinss
}
